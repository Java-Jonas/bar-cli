package main

// this file was generated by sourcing the examples within this repo
var staticCode = map[string]string{
	"importedCode_client": `package client 
import (
	"context"
	"sync"
	"{{path}}/examples/connect"
	"nhooyr.io/websocket"
	"time"
	"{{path}}/examples/logging"
	"{{path}}/examples/message"
	"github.com/rs/zerolog/log"
	"{{path}}/examples/state"
	"errors"
	"github.com/google/uuid"
)
// easyjson:skip
type Client struct {
	fps		int
	id		string
	mu		sync.Mutex
	controller	Controller
	engine		*state.Engine
	conn		connect.Connector
	router		*responseRouter
	receiveID	chan string
	messageChannel	chan [ // easyjson:skip
	]byte
	patchChannel	chan []byte
}
func NewClient(ctx context.Context, controller Controller, fps int) (*Client, error) {
	dialCTX, cancel := context.WithCancel(context.Background())
	defer cancel()
	c, _, err := websocket.Dial(dialCTX, "http://localhost:8080/ws", nil)
	if err != nil {
		log.Err(err).Msg("failed creating client while dialing server")
		return nil, err
	}
	client := Client{fps: fps, controller: controller, conn: connect.NewConnection(c, ctx), router: newReponseRouter(), receiveID: make(chan string), messageChannel: make(chan []byte), patchChannel: make(chan []byte), engine: state.NewEngine()}
	go client.runReadMessages()
	go client.runWriteMessages()
	go client.runEmitPatches()
	select {
	case <-time.After(2 * time.Second):
		cancel()
		return nil, dialCTX.Err()
	case clientID := <-client.receiveID:
		client.id = clientID
		client.engine.ThisClientID = clientID
		break
	}
	return &client, nil
}
func (c *Client) tick() {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.engine.Patch.IsEmpty() {
		return
	}
	c.engine.AssembleUpdateTree()
	updateTreeBytes, err := c.engine.Tree.MarshalJSON()
	if err != nil {
		log.Err(err).Msg("failed marshalling patch")
		return
	}
	c.engine.UpdateState()
	c.patchChannel <- updateTreeBytes
}
func (c *Client) ReadUpdate() [ // TODO maybe return error that signals when anything critical happens
// switch of patchChannel and errorChannel
]byte {
	return <-c.patchChannel
}
func (c *Client) runEmitPatches() {
	ticker := time.NewTicker(time.Second / time.Duration(c.fps))
	for {
		<-ticker.C
		c.tick()
	}
}
func (c *Client) ID() string {
	return c.id
}
func (c *Client) closeConnection(reason string) {
	c.conn.Close(reason)
}
func (c *Client) runReadMessages() {
	defer c.closeConnection("failed reading messages")
	for {
		_, msgBytes, err := c.conn.ReadMessage()
		if err != nil {
			log.Err(err).Msg("failed reading message")
			break
		}
		var msg Message
		err = msg.UnmarshalJSON(msgBytes)
		if err != nil {
			log.Err(err).Str(logging.Message, string(msgBytes)).Msg("failed unmarshalling message")
			continue
		}
		c.processMessage(msg)
	}
}
func (c *Client) runWriteMessages() {
	defer c.closeConnection("failed writing messages")
	for {
		msg, ok := <-c.messageChannel
		if !ok {
			log.Warn().Msg("failed while attempted sending to closed client message channel")
			break
		}
		c.conn.WriteMessage(msg)
	}
}
func (c *Client) processMessage(msg Message) error {
	switch msg.Kind {
	case message.MessageKindID:
		c.receiveID <- string(msg.Content)
	case message.MessageKindUpdate, message.MessageKindCurrentState:
		var patch state.State
		err := patch.UnmarshalJSON(msg.Content)
		if err != nil {
			log.Err(err).Msg("failed unmarshalling patch")
			return err
		}
		c.mu.Lock()
		c.engine.ImportPatch(&patch)
		c.mu.Unlock()
	default:
		c.router.route(msg)
	}
	return nil
}
func (c *Client) SuperMessage(b []byte) error {
	id, err := uuid.NewRandom()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindGlobal)).Msg("failed generating message ID")
		return err
	}
	idString := id.String()
	msg := Message{idString, message.MessageKindGlobal, b}
	msgBytes, err := msg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageID, msg.ID).Str(logging.Message, string(msgBytes)).Str(logging.MessageKind, string(message.MessageKindGlobal)).Msg("failed marshalling message")
		return err
	}
	c.messageChannel <- msgBytes
	return nil
}
var (
	ErrResponseTimeout = errors.New("timeout")
)
type Message struct {
	ID	string		` + "`" + `json:"id"` + "`" + `
	Kind	message.Kind	` + "`" + `json:"kind"` + "`" + `
	Content	[]byte		` + "`" + `json:"content"` + "`" + `
}
func newReponseRouter() *responseRouter {
	return &responseRouter{pending: make(map[string]chan []byte)}
}
// easyjson:skip
type responseRouter struct {
	pending	map // easyjson:skip
	[string]chan []byte
	mu	sync.Mutex
}
func (r *responseRouter) add(id string, ch chan []byte) {
	r.mu.Lock()
	r.pending[id] = ch
	r.mu.Unlock()
}
func (r *responseRouter) remove(id string) {
	r.mu.Lock()
	defer r.mu.Unlock()
	ch, ok := r.pending[id]
	if !ok {
		return
	}
	delete(r.pending, id)
	close(ch)
}
func (r *responseRouter) route(response Message) {
	r.mu.Lock()
	defer r.mu.Unlock()
	ch, ok := r.pending[response.ID]
	if !ok {
		log.Warn().Str(logging.MessageID, response.ID).Msg("cannot find channel for routing response")
		return
	}
	ch <- response.Content
}
`,
	"importedCode_connect": `package connect 
import (
	"nhooyr.io/websocket"
	"context"
	"{{path}}/examples/logging"
	"github.com/rs/zerolog/log"
)
type Connector interface {
	Close(reason string)
	ReadMessage() (messageType int, p []byte, err error)
	WriteMessage(messageType []byte) error
	Context() context.Context
}
// easyjson:skip
type Connection struct {
	Conn		*websocket.Conn
	ctx		context.Context
	cancelFn	func()
}// easyjson:skip

func NewConnection(conn *websocket.Conn, ctx context.Context) *Connection {
	ctx, cancel := context.WithCancel(ctx)
	return &Connection{Conn: conn, ctx: ctx, cancelFn: cancel}
}
func (c *Connection) Context() context.Context {
	return c.ctx
}
func (c *Connection) Close(reason string) {
	err := c.Conn.Close(websocket.StatusNormalClosure, reason)
	if err != nil {
		log.Warn().Msg("failed closing connection")
	}
	c.cancelFn()
}
func (c *Connection) ReadMessage() (int, []byte, error) {
	msgType, msg, err := c.Conn.Read(c.ctx)
	if err != nil {
		log.Err(err).Msg("failed reading from connection")
		return 0, nil, err
	}
	return int(msgType), msg, nil
}
func (c *Connection) WriteMessage(msg []byte) error {
	err := c.Conn.Write(c.ctx, websocket.MessageText, msg)
	if err != nil {
		log.Err(err).Str(logging.Message, string(msg)).Msg("failed writing to connection")
		return err
	}
	return nil
}
`,
	"importedCode_logging": `package logging 
const (
	RoomName		= "roomName"
	ClientID		= "clientID"
	MessageKind		= "messageKind"
	MessageContent		= "messageContent"
	Message			= "message"
	MessageID		= "messageID"
	ClientBufferFull	= "client message buffer full"
)
`,
	"importedCode_message": `package message 
import "{{path}}/examples/state"
type Kind string
const (
	MessageKindError	Kind	= "error"
	MessageKindCurrentState	Kind	= "currentState"
	MessageKindUpdate	Kind	= "update"
	MessageKindID		Kind	= "id"
	MessageKindNoResponse	Kind	= "noResponse"
	MessageKindGlobal	Kind	= "global"
	MessageIDUnknown	string	= "unknown"
)// server -> client
// responses to messages which fail to unmarshal
// client -> server

`,
	"importedCode_server": `package server 
import (
	"{{path}}/examples/message"
	"github.com/rs/zerolog/log"
	"sync"
	"errors"
	"fmt"
	"net/http"
	"nhooyr.io/websocket"
	"github.com/google/uuid"
	"{{path}}/examples/logging"
	"{{path}}/examples/state"
	"time"
	"{{path}}/examples/connect"
)
// easyjson:skip
type Client struct {
	lobby		*Lobby
	room		*Room
	conn		connect.Connector
	messageChannel	chan [ // easyjson:skip
	]byte
	id	string
}
func newClient(websocketConnector connect.Connector, lobby *Lobby) (*Client, error) {
	clientID, err := uuid.NewRandom()
	if err != nil {
		log.Err(err).Msg("failed generating client ID")
		return nil, err
	}
	c := Client{lobby: lobby, conn: websocketConnector, messageChannel: make(chan []byte, 32), id: clientID.String()}
	err = c.sendIdentifyingMessage()
	if err != nil {
		return nil, err
	}
	return &c, nil
}
func (c *Client) sendIdentifyingMessage() error {
	msg := Message{Kind: message.MessageKindID, Content: []byte(c.id)}
	msgBytes, err := msg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Msg("failed marshalling message")
		return err
	}
	c.messageChannel <- msgBytes
	return nil
}
func (c *Client) SendMessage(msg []byte) {
	c.messageChannel <- msg
}
func (c *Client) ID() string {
	return c.id
}
func (c *Client) RoomName() string {
	return c.room.name
}
func (c *Client) closeConnection(reason string) {
	c.conn.Close(reason)
}// closeConnection closes the client's connection
// this does not do anything else on its own, but triggers
// the removal of the client from the system in the
// http handler

func (c *Client) runReadMessages() {
	defer c.closeConnection("failed reading messages")
	for {
		_, msgBytes, err := c.conn.ReadMessage()
		if err != nil {
			break
		}
		var msg Message
		err = msg.UnmarshalJSON(msgBytes)
		if err != nil {
			log.Err(err).Str(logging.Message, string(msgBytes)).Msg("failed unmarshalling message")
			errMsg, _ := Message{message.MessageIDUnknown, message.MessageKindError, []byte("invalid message"), nil}.MarshalJSON()
			c.messageChannel <- errMsg
			continue
		}
		msg.client = c
		if msg.Kind == message.MessageKindGlobal {
			c.lobby.processMessageSync(msg)
		} else {
			if c.room != nil {
				c.room.processMessageSync(msg)
			}
		}
	}
}
func (c *Client) runWriteMessages() {
	defer c.closeConnection("failed writing messages")
	for {
		msgBytes, ok := <-c.messageChannel
		if !ok {
			log.Warn().Str(logging.ClientID, c.id).Msg("client message channel was closed")
			break
		}
		c.conn.WriteMessage(msgBytes)
	}
}
// easyjson:skip
type clientRegistrar struct {
	clients	map // easyjson:skip
	[*Client]struct{}
	incomingClients	map[*Client]struct{}
	mu		sync.Mutex
}
func newClientRegistar() *clientRegistrar {
	return &clientRegistrar{clients: make(map[*Client]struct{}), incomingClients: make(map[*Client]struct{})}
}
func (c *clientRegistrar) add(client *Client) {
	c.mu.Lock()
	defer c.mu.Unlock()
	log.Debug().Str(logging.ClientID, client.id).Msg("adding client")
	c.incomingClients[client] = struct{}{}
}
func (c *clientRegistrar) remove(client *Client) {
	c.mu.Lock()
	defer c.mu.Unlock()
	log.Debug().Str(logging.ClientID, client.id).Msg("removing client")
	delete(c.clients, client)
	delete(c.incomingClients, client)
}
func (c *clientRegistrar) kick(client *Client, reason string) {
	log.Debug().Str(logging.ClientID, client.id).Msg("kicking client")
	client.closeConnection(reason)
}// TODO unused

func (c *clientRegistrar) promote(client *Client) {
	c.mu.Lock()
	defer c.mu.Unlock()
	log.Debug().Str(logging.ClientID, client.id).Msg("promoting client")
	c.clients[client] = struct{}{}
	delete(c.incomingClients, client)
}
var (
	ErrMessageKindUnknown = errors.New("message kind unknown")
)
// easyjson:skip
type Lobby struct {
	mu	sync.Mutex
	Rooms	map // easyjson:skip
	[string]*Room
	controller	Controller
	fps		int
}
func newLobby(controller Controller, fps int) *Lobby {
	l := &Lobby{Rooms: make(map[string]*Room), controller: controller, fps: fps}
	l.signalCreation()
	return l
}
func (l *Lobby) CreateRoom(name string) *Room {
	if room, ok := l.Rooms[name]; ok {
		log.Warn().Str(logging.RoomName, name).Msg("attempted to create room which already exists")
		return room
	}
	room := newRoom(l.controller, name)
	l.Rooms[name] = room
	room.Deploy(l.controller, l.fps)
	return room
}
func (l *Lobby) DeleteRoom(name string) {
	room, ok := l.Rooms[name]
	if !ok {
		log.Warn().Str(logging.RoomName, name).Msg("attempted to delete room which does not exists")
		return
	}
	room.mode = RoomModeTerminating
	delete(l.Rooms, name)
}
func (l *Lobby) addClient(client *Client) {
	l.signalClientConnect(client)
}
func (l *Lobby) deleteClient(client *Client) {
	if client.room != nil {
		client.room.clients.remove(client)
	}
	l.signalClientDisconnect(client)
}
func (l *Lobby) processMessageSync(msg Message) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnSuperMessage(msg, msg.client.room, msg.client, l)
}
func (l *Lobby) signalClientDisconnect(client *Client) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnClientDisconnect(client.room, client.id, l)
}
func (l *Lobby) signalClientConnect(client *Client) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnClientConnect(client, l)
}
func (l *Lobby) signalCreation() {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnCreation(l)
}
type Message struct {
	ID	string		` + "`" + `json:"id"` + "`" + `
	Kind	message.Kind	` + "`" + `json:"kind"` + "`" + `
	Content	[]byte		` + "`" + `json:"content"` + "`" + `
	client	*Client
}
type RoomMode int
const (
	RoomModeIdle	RoomMode	= iota
	RoomModeRunning
	RoomModeTerminating
)
// easyjson:skip
type Room struct {
	name		string
	mu		sync.Mutex
	clients		*clientRegistrar
	state		*state.Engine
	controller	Controller
	mode		RoomMode
}// easyjson:skip

func newRoom(controller Controller, name string) *Room {
	return &Room{name: name, clients: newClientRegistar(), state: state.NewEngine(), controller: controller}
}
func (r *Room) Name() string {
	return r.name
}
func (r *Room) RemoveClient(client *Client) {
	r.clients.remove(client)
}
func (r *Room) AddClient(client *Client) {
	client.room = r
	r.clients.add(client)
}
func (r *Room) AlterState(fn func(*state.Engine)) {
	r.mu.Lock()
	defer r.mu.Unlock()
	fn(r.state)
}
func (r *Room) RangeClients(fn func(client *Client)) {
	for c := range r.clients.incomingClients {
		fn(c)
	}
	for c := range r.clients.clients {
		fn(c)
	}
}
func (r *Room) processMessageSync(msg Message) {
	r.mu.Lock()
	defer r.mu.Unlock()
	response := r.processClientMessage(msg)
	if response.Kind == message.MessageKindNoResponse {
		return
	}
	responseBytes, err := response.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.Message, string(responseBytes)).Str(logging.MessageKind, string(response.Kind)).Msg("failed marshalling response")
		return
	}
	select {
	case response.client.messageChannel <- responseBytes:
	default:
		log.Warn().Str(logging.ClientID, response.client.id).Msg(logging.ClientBufferFull)
		response.client.closeConnection(logging.ClientBufferFull)
	}
}
func (r *Room) run(controller Controller, fps int) {
	ticker := time.NewTicker(time.Second / time.Duration(fps))
	for {
		<-ticker.C
		r.tickSync(controller)
		if r.mode == RoomModeTerminating {
			break
		}
	}
}
func (r *Room) Deploy(controller Controller, fps int) {
	go r.run(controller, fps)
}
// easyjson:skip
type Server struct {
	HttpServer	*http.Server
	Lobby		*Lobby
}// easyjson:skip

func NewServer(controller Controller, fps int, configs ...func(*http.Server, *http.ServeMux)) *Server {
	server := Server{HttpServer: new(http.Server), Lobby: newLobby(controller, fps)}
	handler := http.NewServeMux()
	for _, c := range configs {
		c(server.HttpServer, handler)
	}
	if server.HttpServer.Addr == "" {
		server.HttpServer.Addr = fmt.Sprintf(":%d", 8080)
	}
	handler.HandleFunc("/", homePageHandler)
	handler.HandleFunc("/ws", server.wsEndpoint)
	server.HttpServer.Handler = handler
	return &server
}
func homePageHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Home Page")
}
func (s *Server) wsEndpoint(w http.ResponseWriter, r *http.Request) {
	websocketConnection, err := websocket.Accept(w, r, &websocket.AcceptOptions{InsecureSkipVerify: true})
	if err != nil {
		log.Err(err).Msg("failed creating websocket connection")
		return
	}
	client, err := newClient(connect.NewConnection(websocketConnection, r.Context()), s.Lobby)
	if err != nil {
		return
	}
	s.Lobby.addClient(client)
	go client.runReadMessages()
	go client.runWriteMessages()
	<-client.conn.Context().Done()
	log.Debug().Msg("client context done")
	s.Lobby.deleteClient(client)
}
func (s *Server) Start() chan error {
	log.Info().Msgf("backent running on port %s\n", s.HttpServer.Addr)
	serverError := make(chan error)
	go func() {
		err := s.HttpServer.ListenAndServe()
		serverError <- err
	}()
	return serverError
}
func (r *Room) tickSync(controller Controller) {
	r.mu.Lock()
	defer r.mu.Unlock()
	controller.OnFrameTick(r.state)
	err := r.publishPatch()
	if err != nil {
		return
	}
	r.state.UpdateState()
	r.handleIncomingClients()
}
func (r *Room) publishPatch() error {
	if r.state.Patch.IsEmpty() {
		return nil
	}
	patchBytes, err := r.state.Patch.MarshalJSON()
	if err != nil {
		log.Err(err).Msg("failed marshalling patch")
		return err
	}
	stateUpdateMsg := Message{Kind: message.MessageKindUpdate, Content: patchBytes}
	stateUpdateBytes, err := stateUpdateMsg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(stateUpdateMsg.Kind)).Msg("failed marshalling message")
		return err
	}
	r.broadcastPatchToClients(stateUpdateBytes)
	return nil
}
func (r *Room) broadcastPatchToClients(stateUpdateBytes []byte) {
	for client := range r.clients.clients {
		select {
		case client.messageChannel <- stateUpdateBytes:
		default:
			log.Warn().Str(logging.ClientID, client.id).Msg(logging.ClientBufferFull)
			client.closeConnection(logging.ClientBufferFull)
		}
	}
}
func (r *Room) handleIncomingClients() {
	if len(r.clients.incomingClients) == 0 {
		return
	}
	stateBytes, err := r.state.State.MarshalJSON()
	if err != nil {
		log.Err(err).Msg("failed marshalling state")
		return
	}
	currentStateMsg := Message{Kind: message.MessageKindCurrentState, Content: stateBytes}
	currentStateMessageBytes, err := currentStateMsg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(currentStateMsg.Kind)).Msg("failed marshalling message")
		return
	}
	for client := range r.clients.incomingClients {
		select {
		case client.messageChannel <- currentStateMessageBytes:
			r.clients.promote(client)
		default:
			log.Warn().Str(logging.ClientID, client.id).Msg(logging.ClientBufferFull)
			client.closeConnection(logging.ClientBufferFull)
		}
	}
}
`,
	"importedCode_state": `package state 
import (
	"bytes"
	"fmt"
	"strconv"
	"sort"
	"sync"
)
`,
}
