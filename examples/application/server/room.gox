package state

// type Room struct {
// 	clients                 map[*Client]bool
// 	clientMessageChannel    chan Message
// 	pendingResponsesChannel chan Message
// 	registerChannel         chan *Client
// 	unregisterChannel       chan *Client
// 	incomingClients         map[*Client]bool
// 	state                   *Engine
// 	actions                 Actions
// 	sideEffects             SideEffects
// 	fps                     int
// 	terminate               chan struct{}
// 	terminated              chan struct{}
// }

// func newRoom(actions Actions, sideEffects SideEffects, fps int) *Room {
// 	return &Room{
// 		clients:                 make(map[*Client]bool),
// 		clientMessageChannel:    make(chan Message, 1024),
// 		pendingResponsesChannel: make(chan Message, 1024),
// 		unregisterChannel:       make(chan *Client),
// 		registerChannel:         make(chan *Client),
// 		incomingClients:         make(map[*Client]bool),
// 		state:                   newEngine(),
// 		sideEffects:             sideEffects,
// 		actions:                 actions,
// 		fps:                     fps,
// 		terminate:               make(chan struct{}),
// 		terminated:              make(chan struct{}, 1),
// 	}
// }

// func (r *Room) registerClient(client *Client) {
// 	r.incomingClients[client] = true
// }

// func (r *Room) promoteIncomingClient(client *Client) {
// 	r.clients[client] = true
// 	delete(r.incomingClients, client)
// }

// func (r *Room) processFrame() {
// Exit:
// 	for {
// 		select {
// 		case msg := <-r.clientMessageChannel:
// 			response, err := r.processClientMessage(msg)
// 			if err != nil {
// 				log.Println("error processing client message:", err)
// 				continue
// 			}

// 			// actions may not have a response
// 			// which means `response` is empty here
// 			// and can be skipped
// 			if response.client == nil {
// 				continue
// 			}

// 			select {
// 			case r.pendingResponsesChannel <- response:
// 			default:
// 				log.Printf("pending responses channel full, continuing with tick")
// 				// remaining messages in clientMessageChannel will be processed next tick
// 				break Exit
// 			}

// 		default:
// 			// clientMessageChannel is empty for now
// 			break Exit
// 		}
// 	}

// 	if r.sideEffects.OnFrameTick != nil {
// 		r.sideEffects.OnFrameTick(r.state)
// 	}
// }

// func (r *Room) handlePendingResponses() {
// Exit:
// 	for {
// 		select {
// 		case pendingResponse := <-r.pendingResponsesChannel:

// 			response, err := pendingResponse.MarshalJSON()
// 			if err != nil {
// 				log.Printf("error marshalling pending response message: %s", err)
// 				continue
// 			}

// 			select {
// 			case pendingResponse.client.messageChannel <- response:
// 			default:
// 				log.Printf("client's message buffer full -> dropping client %s", pendingResponse.client.id)
// 				pendingResponse.client.conn.Close()
// 				r.unregisterClient(pendingResponse.client)
// 			}

// 		default:
// 			// pendingResponsesChannel is empty for now
// 			break Exit
// 		}
// 	}
// }

// func (r *Room) Deploy() {
// 	if r.sideEffects.OnDeploy != nil {
// 		r.sideEffects.OnDeploy(r.state)
// 	}

// 	go r.run()
// }
