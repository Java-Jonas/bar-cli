// this file was generated by https://github.com/jobergner/decltostring

package client

const actions_generated_go_import string = `import (
	"time"
	"github.com/google/uuid"
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/rs/zerolog/log"
)`

const _AddItemToPlayer_Client_func string = `func (c *Client) AddItemToPlayer(params message.AddItemToPlayerParams) (message.AddItemToPlayerResponse, error) {
	c.mu.Lock()
	c.controller.AddItemToPlayerBroadcast(params, c.engine, "", c.id)
	c.mu.Unlock()
	msgContent, err := params.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_addItemToPlayer)).Msg("failed marshalling parameters")
		return message.AddItemToPlayerResponse{}, err
	}
	id, err := uuid.NewRandom()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_addItemToPlayer)).Msg("failed generating message ID")
		return message.AddItemToPlayerResponse{}, err
	}
	idString := id.String()
	msg := Message{idString, message.MessageKindAction_addItemToPlayer, msgContent}
	msgBytes, err := msg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_addItemToPlayer)).Str(logging.MessageID, msg.ID).Str(logging.Message, string(msgBytes)).Msg("failed marshalling message")
		return message.AddItemToPlayerResponse{}, err
	}
	responseChan := make(chan []byte)
	c.router.add(idString, responseChan)
	defer c.router.remove(idString)
	c.messageChannel <- msgBytes
	select {
	case <-time.After(2 * time.Second):
		log.Err(ErrResponseTimeout).Str(logging.MessageID, msg.ID).Msg("timed out waiting for response")
		return message.AddItemToPlayerResponse{}, ErrResponseTimeout
	case responseBytes := <-responseChan:
		var res message.AddItemToPlayerResponse
		err := res.UnmarshalJSON(responseBytes)
		if err != nil {
			log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_addItemToPlayer)).Str(logging.MessageID, msg.ID).Msg("failed unmarshalling response")
			return message.AddItemToPlayerResponse{}, err
		}
		return res, nil
	}
}`

const _MovePlayer_Client_func string = `func (c *Client) MovePlayer(params message.MovePlayerParams) error {
	c.mu.Lock()
	c.controller.MovePlayerBroadcast(params, c.engine, "", c.id)
	c.mu.Unlock()
	msgContent, err := params.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_movePlayer)).Msg("failed marshalling parameters")
		return err
	}
	id, err := uuid.NewRandom()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_movePlayer)).Msg("failed generating message ID")
		return err
	}
	idString := id.String()
	msg := Message{idString, message.MessageKindAction_movePlayer, msgContent}
	msgBytes, err := msg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_movePlayer)).Str(logging.MessageID, msg.ID).Str(logging.Message, string(msgBytes)).Msg("failed marshalling message")
		return err
	}
	c.messageChannel <- msgBytes
	return nil
}`

const _SpawnZoneItems_Client_func string = `func (c *Client) SpawnZoneItems(params message.SpawnZoneItemsParams) (message.SpawnZoneItemsResponse, error) {
	c.mu.Lock()
	c.controller.SpawnZoneItemsBroadcast(params, c.engine, "", c.id)
	c.mu.Unlock()
	msgContent, err := params.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_spawnZoneItems)).Msg("failed marshalling parameters")
		return message.SpawnZoneItemsResponse{}, err
	}
	id, err := uuid.NewRandom()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_spawnZoneItems)).Msg("failed generating message ID")
		return message.SpawnZoneItemsResponse{}, err
	}
	idString := id.String()
	msg := Message{idString, message.MessageKindAction_spawnZoneItems, msgContent}
	msgBytes, err := msg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_spawnZoneItems)).Str(logging.MessageID, msg.ID).Str(logging.Message, string(msgBytes)).Msg("failed marshalling message")
		return message.SpawnZoneItemsResponse{}, err
	}
	responseChan := make(chan []byte)
	c.router.add(idString, responseChan)
	defer c.router.remove(idString)
	c.messageChannel <- msgBytes
	select {
	case <-time.After(2 * time.Second):
		log.Err(ErrResponseTimeout).Str(logging.MessageID, msg.ID).Msg("timed out waiting for response")
		return message.SpawnZoneItemsResponse{}, ErrResponseTimeout
	case responseBytes := <-responseChan:
		var res message.SpawnZoneItemsResponse
		err := res.UnmarshalJSON(responseBytes)
		if err != nil {
			log.Err(err).Str(logging.MessageKind, string(message.MessageKindAction_spawnZoneItems)).Str(logging.MessageID, msg.ID).Msg("failed unmarshalling response")
			return message.SpawnZoneItemsResponse{}, err
		}
		return res, nil
	}
}`

const client_go_import string = `import (
	"context"
	"sync"
	"time"
	"github.com/google/uuid"
	"github.com/jobergner/backent-cli/examples/connect"
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/jobergner/backent-cli/examples/state"
	"github.com/rs/zerolog/log"
	"nhooyr.io/websocket"
)`

const _Client_type string = `type Client struct {
	fps		int
	id		string
	mu		sync.Mutex
	controller	Controller
	engine		*state.Engine
	conn		connect.Connector
	router		*responseRouter
	receiveID	chan string
	messageChannel	chan []byte
	patchChannel	chan []byte
}`

const _NewClient_func string = `func NewClient(ctx context.Context, controller Controller, fps int) (*Client, error) {
	dialCTX, cancel := context.WithCancel(context.Background())
	defer cancel()
	c, _, err := websocket.Dial(dialCTX, "http://localhost:8080/ws", nil)
	if err != nil {
		log.Err(err).Msg("failed creating client while dialing server")
		return nil, err
	}
	client := Client{fps: fps, controller: controller, conn: connect.NewConnection(c, ctx), router: newReponseRouter(), receiveID: make(chan string), messageChannel: make(chan []byte), patchChannel: make(chan []byte), engine: state.NewEngine()}
	go client.runReadMessages()
	go client.runWriteMessages()
	go client.runEmitPatches()
	select {
	case <-time.After(2 * time.Second):
		cancel()
		return nil, dialCTX.Err()
	case clientID := <-client.receiveID:
		client.id = clientID
		client.engine.ThisClientID = clientID
		break
	}
	return &client, nil
}`

const tick_Client_func string = `func (c *Client) tick() {
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.engine.Patch.IsEmpty() {
		return
	}
	c.engine.AssembleUpdateTree()
	updateTreeBytes, err := c.engine.Tree.MarshalJSON()
	if err != nil {
		log.Err(err).Msg("failed marshalling patch")
		return
	}
	c.engine.UpdateState()
	c.patchChannel <- updateTreeBytes
}`

const _ReadUpdate_Client_func string = `func (c *Client) ReadUpdate() []byte {
	return <-c.patchChannel
}`

const runEmitPatches_Client_func string = `func (c *Client) runEmitPatches() {
	ticker := time.NewTicker(time.Second / time.Duration(c.fps))
	for {
		<-ticker.C
		c.tick()
	}
}`

const _ID_Client_func string = `func (c *Client) ID() string {
	return c.id
}`

const closeConnection_Client_func string = `func (c *Client) closeConnection(reason string) {
	c.conn.Close(reason)
}`

const runReadMessages_Client_func string = `func (c *Client) runReadMessages() {
	defer c.closeConnection("failed reading messages")
	for {
		_, msgBytes, err := c.conn.ReadMessage()
		if err != nil {
			log.Err(err).Msg("failed reading message")
			break
		}
		var msg Message
		err = msg.UnmarshalJSON(msgBytes)
		if err != nil {
			log.Err(err).Str(logging.Message, string(msgBytes)).Msg("failed unmarshalling message")
			continue
		}
		c.processMessage(msg)
	}
}`

const runWriteMessages_Client_func string = `func (c *Client) runWriteMessages() {
	defer c.closeConnection("failed writing messages")
	for {
		msg, ok := <-c.messageChannel
		if !ok {
			log.Warn().Msg("failed while attempted sending to closed client message channel")
			break
		}
		c.conn.WriteMessage(msg)
	}
}`

const processMessage_Client_func string = `func (c *Client) processMessage(msg Message) error {
	switch msg.Kind {
	case message.MessageKindID:
		c.receiveID <- string(msg.Content)
	case message.MessageKindUpdate, message.MessageKindCurrentState:
		var patch state.State
		err := patch.UnmarshalJSON(msg.Content)
		if err != nil {
			log.Err(err).Msg("failed unmarshalling patch")
			return err
		}
		c.mu.Lock()
		c.engine.ImportPatch(&patch)
		c.mu.Unlock()
	default:
		c.router.route(msg)
	}
	return nil
}`

const _SuperMessage_Client_func string = `func (c *Client) SuperMessage(b []byte) error {
	id, err := uuid.NewRandom()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(message.MessageKindGlobal)).Msg("failed generating message ID")
		return err
	}
	idString := id.String()
	msg := Message{idString, message.MessageKindGlobal, b}
	msgBytes, err := msg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageID, msg.ID).Str(logging.Message, string(msgBytes)).Str(logging.MessageKind, string(message.MessageKindGlobal)).Msg("failed marshalling message")
		return err
	}
	c.messageChannel <- msgBytes
	return nil
}`

const controller_generated_go_import string = `import (
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/jobergner/backent-cli/examples/state"
)`

const _Controller_type string = `type Controller interface {
	AddItemToPlayerBroadcast(params message.AddItemToPlayerParams, engine *state.Engine, roomName, clientID string)
	AddItemToPlayerEmit(params message.AddItemToPlayerParams, engine *state.Engine, roomName, clientID string) message.AddItemToPlayerResponse
	MovePlayerBroadcast(params message.MovePlayerParams, engine *state.Engine, roomName, clientID string)
	MovePlayerEmit(params message.MovePlayerParams, engine *state.Engine, roomName, clientID string)
	SpawnZoneItemsBroadcast(params message.SpawnZoneItemsParams, engine *state.Engine, roomName, clientID string)
	SpawnZoneItemsEmit(params message.SpawnZoneItemsParams, engine *state.Engine, roomName, clientID string) message.SpawnZoneItemsResponse
}`

const error_go_import string = `import "errors"`

const _ErrResponseTimeout_type string = `var (
	ErrResponseTimeout = errors.New("timeout")
)`

const message_go_import string = `import "github.com/jobergner/backent-cli/examples/message"`

const _Message_type string = `type Message struct {
	ID	string		` + "`" + `json:"id"` + "`" + `
	Kind	message.Kind	` + "`" + `json:"kind"` + "`" + `
	Content	[]byte		` + "`" + `json:"content"` + "`" + `
}`

const response_router_go_import string = `import (
	"sync"
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/rs/zerolog/log"
)`

const newReponseRouter_func string = `func newReponseRouter() *responseRouter {
	return &responseRouter{pending: make(map[string]chan []byte)}
}`

const responseRouter_type string = `type responseRouter struct {
	pending	map[string]chan []byte
	mu	sync.Mutex
}`

const add_responseRouter_func string = `func (r *responseRouter) add(id string, ch chan []byte) {
	r.mu.Lock()
	r.pending[id] = ch
	r.mu.Unlock()
}`

const remove_responseRouter_func string = `func (r *responseRouter) remove(id string) {
	r.mu.Lock()
	defer r.mu.Unlock()
	ch, ok := r.pending[id]
	if !ok {
		return
	}
	delete(r.pending, id)
	close(ch)
}`

const route_responseRouter_func string = `func (r *responseRouter) route(response Message) {
	r.mu.Lock()
	defer r.mu.Unlock()
	ch, ok := r.pending[response.ID]
	if !ok {
		log.Warn().Str(logging.MessageID, response.ID).Msg("cannot find channel for routing response")
		return
	}
	ch <- response.Content
}`
