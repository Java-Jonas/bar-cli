// this file was generated by https://github.com/jobergner/decltostring

package server

const client_go_import string = `import (
	"github.com/google/uuid"
	"github.com/jobergner/backent-cli/examples/connect"
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/rs/zerolog/log"
)`

const _Client_type string = `type Client struct {
	lobby		*Lobby
	room		*Room
	conn		connect.Connector
	messageChannel	chan []byte
	id		string
}`

const newClient_func string = `func newClient(websocketConnector connect.Connector, lobby *Lobby) (*Client, error) {
	clientID, err := uuid.NewRandom()
	if err != nil {
		log.Err(err).Msg("failed generating client ID")
		return nil, err
	}
	c := Client{lobby: lobby, conn: websocketConnector, messageChannel: make(chan []byte, 32), id: clientID.String()}
	err = c.sendIdentifyingMessage()
	if err != nil {
		return nil, err
	}
	return &c, nil
}`

const sendIdentifyingMessage_Client_func string = `func (c *Client) sendIdentifyingMessage() error {
	msg := Message{Kind: message.MessageKindID, Content: []byte(c.id)}
	msgBytes, err := msg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Msg("failed marshalling message")
		return err
	}
	c.messageChannel <- msgBytes
	return nil
}`

const _ID_Client_func string = `func (c *Client) ID() string {
	return c.id
}`

const _RoomName_Client_func string = `func (c *Client) RoomName() string {
	return c.room.name
}`

const closeConnection_Client_func string = `func (c *Client) closeConnection(reason string) {
	c.conn.Close(reason)
}`

const runReadMessages_Client_func string = `func (c *Client) runReadMessages() {
	defer c.closeConnection("failed reading messages")
	for {
		_, msgBytes, err := c.conn.ReadMessage()
		if err != nil {
			break
		}
		var msg Message
		err = msg.UnmarshalJSON(msgBytes)
		if err != nil {
			log.Err(err).Str(logging.Message, string(msgBytes)).Msg("failed unmarshalling message")
			continue
		}
		msg.client = c
		if msg.Kind == message.MessageKindGlobal {
			c.lobby.processMessage(msg)
		} else {
			if c.room != nil {
				c.room.processMessage(msg)
			}
		}
	}
}`

const runWriteMessages_Client_func string = `func (c *Client) runWriteMessages() {
	defer c.closeConnection("failed writing messages")
	for {
		msgBytes, ok := <-c.messageChannel
		if !ok {
			log.Warn().Str(logging.ClientID, c.id).Msg("client message channel was closed")
			break
		}
		c.conn.WriteMessage(msgBytes)
	}
}`

const client_registrar_go_import string = `import (
	"sync"
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/rs/zerolog/log"
)`

const clientRegistrar_type string = `type clientRegistrar struct {
	clients		map[*Client]struct{}
	incomingClients	map[*Client]struct{}
	mu		sync.Mutex
}`

const newClientRegistar_func string = `func newClientRegistar() *clientRegistrar {
	return &clientRegistrar{clients: make(map[*Client]struct{}), incomingClients: make(map[*Client]struct{})}
}`

const add_clientRegistrar_func string = `func (c *clientRegistrar) add(client *Client) {
	c.mu.Lock()
	defer c.mu.Unlock()
	log.Debug().Str(logging.ClientID, client.id).Msg("adding client")
	c.incomingClients[client] = struct{}{}
}`

const remove_clientRegistrar_func string = `func (c *clientRegistrar) remove(client *Client) {
	c.mu.Lock()
	defer c.mu.Unlock()
	log.Debug().Str(logging.ClientID, client.id).Msg("removing client")
	delete(c.clients, client)
	delete(c.incomingClients, client)
}`

const kick_clientRegistrar_func string = `func (c *clientRegistrar) kick(client *Client, reason string) {
	log.Debug().Str(logging.ClientID, client.id).Msg("kicking client")
	client.closeConnection(reason)
}`

const promote_clientRegistrar_func string = `func (c *clientRegistrar) promote(client *Client) {
	c.mu.Lock()
	defer c.mu.Unlock()
	log.Debug().Str(logging.ClientID, client.id).Msg("promoting client")
	c.clients[client] = struct{}{}
	delete(c.incomingClients, client)
}`

const controller_generated_go_import string = `import (
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/jobergner/backent-cli/examples/state"
)`

const _Controller_type string = `type Controller interface {
	OnSuperMessage(msg Message, room *Room, client *Client, lobby *Lobby)
	OnClientConnect(client *Client, lobby *Lobby)
	OnClientDisconnect(room *Room, clientID string, lobby *Lobby)
	OnCreation(lobby *Lobby)
	OnFrameTick(engine *state.Engine)
	AddItemToPlayer(params message.AddItemToPlayerParams, engine *state.Engine, roomName, clientID string) message.AddItemToPlayerResponse
	MovePlayer(params message.MovePlayerParams, engine *state.Engine, roomName, clientID string)
	SpawnZoneItems(params message.SpawnZoneItemsParams, engine *state.Engine, roomName, clientID string) message.SpawnZoneItemsResponse
}`

const error_go_import string = `import "errors"`

const _ErrMessageKindUnknown_type string = `var (
	ErrMessageKindUnknown = errors.New("message kind unknown")
)`

const lobby_go_import string = `import (
	"sync"
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/rs/zerolog/log"
)`

const _Lobby_type string = `type Lobby struct {
	mu		sync.Mutex
	Rooms		map[string]*Room
	controller	Controller
	fps		int
}`

const newLobby_func string = `func newLobby(controller Controller, fps int) *Lobby {
	l := &Lobby{Rooms: make(map[string]*Room), controller: controller, fps: fps}
	l.signalCreation()
	return l
}`

const _CreateRoom_Lobby_func string = `func (l *Lobby) CreateRoom(name string) *Room {
	if room, ok := l.Rooms[name]; ok {
		log.Warn().Str(logging.RoomName, name).Msg("attempted to create room which already exists")
		return room
	}
	room := newRoom(l.controller, name)
	l.Rooms[name] = room
	room.Deploy(l.fps)
	return room
}`

const _DeleteRoom_Lobby_func string = `func (l *Lobby) DeleteRoom(name string) {
	room, ok := l.Rooms[name]
	if !ok {
		log.Warn().Str(logging.RoomName, name).Msg("attempted to delete room which does not exists")
		return
	}
	room.mode = RoomModeTerminating
	delete(l.Rooms, name)
}`

const addClient_Lobby_func string = `func (l *Lobby) addClient(client *Client) {
	l.signalClientConnect(client)
}`

const deleteClient_Lobby_func string = `func (l *Lobby) deleteClient(client *Client) {
	if client.room != nil {
		client.room.clients.remove(client)
	}
	l.signalClientDisconnect(client)
}`

const processMessage_Lobby_func string = `func (l *Lobby) processMessage(msg Message) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnSuperMessage(msg, msg.client.room, msg.client, l)
}`

const signalClientDisconnect_Lobby_func string = `func (l *Lobby) signalClientDisconnect(client *Client) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnClientDisconnect(client.room, client.id, l)
}`

const signalClientConnect_Lobby_func string = `func (l *Lobby) signalClientConnect(client *Client) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnClientConnect(client, l)
}`

const signalCreation_Lobby_func string = `func (l *Lobby) signalCreation() {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.controller.OnCreation(l)
}`

const message_go_import string = `import "github.com/jobergner/backent-cli/examples/message"`

const _Message_type string = `type Message struct {
	ID	string		` + "`" + `json:"id"` + "`" + `
	Kind	message.Kind	` + "`" + `json:"kind"` + "`" + `
	Content	[]byte		` + "`" + `json:"content"` + "`" + `
	client	*Client
}`

const process_message_generated_go_import string = `import (
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/rs/zerolog/log"
)`

const triggerAction_Room_func string = `func (r *Room) triggerAction(msg Message) Message {
	r.mu.Lock()
	defer r.mu.Unlock()
	switch msg.Kind {
	case message.MessageKindAction_addItemToPlayer:
		var params message.AddItemToPlayerParams
		err := params.UnmarshalJSON(msg.Content)
		if err != nil {
			log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Str(logging.MessageContent, string(msg.Content)).Msg("failed unmarshalling params")
			return Message{msg.ID, message.MessageKindError, []byte("invalid message"), msg.client}
		}
		res := r.controller.AddItemToPlayer(params, r.state, r.name, msg.client.id)
		resContent, err := res.MarshalJSON()
		if err != nil {
			log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Msg("failed marshalling response content")
			return Message{msg.ID, message.MessageKindError, []byte("invalid message"), msg.client}
		}
		return Message{msg.ID, msg.Kind, resContent, msg.client}
	case message.MessageKindAction_movePlayer:
		var params message.MovePlayerParams
		err := params.UnmarshalJSON(msg.Content)
		if err != nil {
			log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Str(logging.MessageContent, string(msg.Content)).Msg("failed unmarshalling params")
			return Message{msg.ID, message.MessageKindError, []byte("invalid message"), msg.client}
		}
		r.controller.MovePlayer(params, r.state, r.name, msg.client.id)
		return Message{ID: msg.ID, Kind: message.MessageKindNoResponse}
	case message.MessageKindAction_spawnZoneItems:
		var params message.SpawnZoneItemsParams
		err := params.UnmarshalJSON(msg.Content)
		if err != nil {
			log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Str(logging.MessageContent, string(msg.Content)).Msg("failed unmarshalling params")
			return Message{msg.ID, message.MessageKindError, []byte("invalid message"), msg.client}
		}
		res := r.controller.SpawnZoneItems(params, r.state, r.name, msg.client.id)
		resContent, err := res.MarshalJSON()
		if err != nil {
			log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Msg("failed marshalling response content")
			return Message{msg.ID, message.MessageKindError, []byte("invalid message"), msg.client}
		}
		return Message{msg.ID, msg.Kind, resContent, msg.client}
	default:
		err := ErrMessageKindUnknown
		log.Err(err).Str(logging.MessageKind, string(msg.Kind)).Msg("unknown message kind")
		return Message{msg.ID, message.MessageKindError, []byte("invalid message"), msg.client}
	}
}`

const room_go_import string = `import (
	"sync"
	"time"
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/jobergner/backent-cli/examples/state"
	"github.com/rs/zerolog/log"
)`

const _RoomMode_type string = `type RoomMode int`

const _RoomModeIdle_type string = `const (
	RoomModeIdle	RoomMode	= iota
	RoomModeRunning
	RoomModeTerminating
)`

const _Room_type string = `type Room struct {
	name		string
	mu		sync.Mutex
	clients		*clientRegistrar
	state		*state.Engine
	controller	Controller
	mode		RoomMode
}`

const newRoom_func string = `func newRoom(controller Controller, name string) *Room {
	return &Room{name: name, clients: newClientRegistar(), state: state.NewEngine(), controller: controller}
}`

const _Name_Room_func string = `func (r *Room) Name() string {
	return r.name
}`

const _RemoveClient_Room_func string = `func (r *Room) RemoveClient(client *Client) {
	r.clients.remove(client)
}`

const _AddClient_Room_func string = `func (r *Room) AddClient(client *Client) {
	client.room = r
	r.clients.add(client)
}`

const _AlterState_Room_func string = `func (r *Room) AlterState(fn func(*state.Engine)) {
	r.mu.Lock()
	defer r.mu.Unlock()
	fn(r.state)
}`

const processMessage_Room_func string = `func (r *Room) processMessage(msg Message) {
	response := r.triggerAction(msg)
	if response.Kind == message.MessageKindNoResponse {
		return
	}
	responseBytes, err := response.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.Message, string(responseBytes)).Str(logging.MessageKind, string(response.Kind)).Msg("failed marshalling response")
		return
	}
	select {
	case response.client.messageChannel <- responseBytes:
	default:
		log.Warn().Str(logging.ClientID, response.client.id).Msg(logging.ClientBufferFull)
		response.client.closeConnection(logging.ClientBufferFull)
	}
}`

const run_Room_func string = `func (r *Room) run(fps int) {
	ticker := time.NewTicker(time.Second / time.Duration(fps))
	for {
		<-ticker.C
		r.tick()
		if r.mode == RoomModeTerminating {
			break
		}
	}
}`

const _Deploy_Room_func string = `func (r *Room) Deploy(fps int) {
	go r.run(fps)
}`

const server_go_import string = `import (
	"fmt"
	"net/http"
	"github.com/jobergner/backent-cli/examples/connect"
	"github.com/rs/zerolog/log"
	"nhooyr.io/websocket"
)`

const _Server_type string = `type Server struct {
	HttpServer	*http.Server
	Lobby		*Lobby
}`

const _NewServer_func string = `func NewServer(controller Controller, fps int, configs ...func(*http.Server, *http.ServeMux)) *Server {
	server := Server{HttpServer: new(http.Server), Lobby: newLobby(controller, fps)}
	handler := http.NewServeMux()
	for _, c := range configs {
		c(server.HttpServer, handler)
	}
	if server.HttpServer.Addr == "" {
		server.HttpServer.Addr = fmt.Sprintf(":%d", 8080)
	}
	handler.HandleFunc("/", homePageHandler)
	handler.HandleFunc("/ws", server.wsEndpoint)
	server.HttpServer.Handler = handler
	return &server
}`

const homePageHandler_func string = `func homePageHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Home Page")
}`

const wsEndpoint_Server_func string = `func (s *Server) wsEndpoint(w http.ResponseWriter, r *http.Request) {
	websocketConnection, err := websocket.Accept(w, r, &websocket.AcceptOptions{InsecureSkipVerify: true})
	if err != nil {
		log.Err(err).Msg("failed creating websocket connection")
		return
	}
	client, err := newClient(connect.NewConnection(websocketConnection, r.Context()), s.Lobby)
	if err != nil {
		return
	}
	s.Lobby.addClient(client)
	go client.runReadMessages()
	go client.runWriteMessages()
	<-client.conn.Context().Done()
	log.Debug().Msg("client context done")
	s.Lobby.deleteClient(client)
}`

const _Start_Server_func string = `func (s *Server) Start() chan error {
	log.Info().Msgf("server running on port %s\n", s.HttpServer.Addr)
	serverError := make(chan error)
	go func() {
		err := s.HttpServer.ListenAndServe()
		serverError <- err
	}()
	return serverError
}`

const tick_go_import string = `import (
	"github.com/jobergner/backent-cli/examples/logging"
	"github.com/jobergner/backent-cli/examples/message"
	"github.com/rs/zerolog/log"
)`

const tick_Room_func string = `func (r *Room) tick() {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.controller.OnFrameTick(r.state)
	err := r.publishPatch()
	if err != nil {
		return
	}
	r.state.UpdateState()
	r.handleIncomingClients()
}`

const publishPatch_Room_func string = `func (r *Room) publishPatch() error {
	if r.state.Patch.IsEmpty() {
		return nil
	}
	patchBytes, err := r.state.Patch.MarshalJSON()
	if err != nil {
		log.Err(err).Msg("failed marshalling patch")
		return err
	}
	stateUpdateMsg := Message{Kind: message.MessageKindUpdate, Content: patchBytes}
	stateUpdateBytes, err := stateUpdateMsg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(stateUpdateMsg.Kind)).Msg("failed marshalling message")
		return err
	}
	r.broadcastPatchToClients(stateUpdateBytes)
	return nil
}`

const broadcastPatchToClients_Room_func string = `func (r *Room) broadcastPatchToClients(stateUpdateBytes []byte) {
	for client := range r.clients.clients {
		select {
		case client.messageChannel <- stateUpdateBytes:
		default:
			log.Warn().Str(logging.ClientID, client.id).Msg(logging.ClientBufferFull)
			client.closeConnection(logging.ClientBufferFull)
		}
	}
}`

const handleIncomingClients_Room_func string = `func (r *Room) handleIncomingClients() {
	if len(r.clients.incomingClients) == 0 {
		return
	}
	stateBytes, err := r.state.State.MarshalJSON()
	if err != nil {
		log.Err(err).Msg("failed marshalling state")
		return
	}
	currentStateMsg := Message{Kind: message.MessageKindCurrentState, Content: stateBytes}
	currentStateMessageBytes, err := currentStateMsg.MarshalJSON()
	if err != nil {
		log.Err(err).Str(logging.MessageKind, string(currentStateMsg.Kind)).Msg("failed marshalling message")
		return
	}
	for client := range r.clients.incomingClients {
		select {
		case client.messageChannel <- currentStateMessageBytes:
			r.clients.promote(client)
		default:
			log.Warn().Str(logging.ClientID, client.id).Msg(logging.ClientBufferFull)
			client.closeConnection(logging.ClientBufferFull)
		}
	}
}`
