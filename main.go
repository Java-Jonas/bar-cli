package main

import (
	"bytes"
	"flag"
	// "fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func check(err error) {
	if err != nil {
		panic(err)
	}
}

type inputFile struct {
	name  string
	path  string
	decls []ast.Decl
}

func newInputFile(name, path string, content []byte) inputFile {
	f, err := parser.ParseFile(token.NewFileSet(), "", content, 0)
	check(err)

	file := inputFile{
		name:  name,
		path:  path,
		decls: f.Decls,
	}

	return file
}

type outputFile struct {
	name       string
	declPrefix string
	content    bytes.Buffer
}

func newOutputFile(name, declPrefix, packageName string) outputFile {
	var content bytes.Buffer

	content.WriteString("// this file was generated by https://github.com/Java-Jonas/decltostring\n\n")
	content.WriteString("package " + packageName + "\n\n")

	return outputFile{name, declPrefix, content}
}

func (o *outputFile) writeFile() {
	err := ioutil.WriteFile(o.name, o.content.Bytes(), 0644)
	check(err)
}

func (o *outputFile) formatContent() *outputFile {
	fileSet := token.NewFileSet()
	f, err := parser.ParseFile(fileSet, "", o.content, parser.ParseComments)
	check(err)
	var formattedContent bytes.Buffer
	printer.Fprint(&formattedContent, fileSet, f)
	o.content = formattedContent
	return o
}

func escapeBackticks(s string) string {
	return strings.Replace(s, "`", "` + \"`\" +  `", -1)
}

func (o *outputFile) writeDecl(decl ast.Decl, containingFileName string) {

	outputDeclName := evalDeclName(decl, containingFileName)
	if o.declPrefix != "" {
		outputDeclName = o.declPrefix + "_" + outputDeclName
	}
	outputDeclValue := escapeBackticks(stringifyDecl(decl))

	o.content.WriteString("\n\nconst " + outputDeclName + " string = `" + outputDeclValue + "`")
}

func scanFiles(directoryPath string) []inputFile {
	var files []inputFile

	err := filepath.Walk(directoryPath, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".go" {
			return nil
		}

		content, err := ioutil.ReadFile(path)
		check(err)
		files = append(files, newInputFile(info.Name(), path, content))
		return nil
	})

	check(err)

	return files
}

func evalDeclName(decl ast.Decl, containingFileName string) string {
	if isImportDecl(decl) {
		importName := evalImportName(containingFileName)
		return importName + "_import"
	}
	if isFuncDecl(decl) {
		return getFuncName(decl.(*ast.FuncDecl)) + "_func"
	}
	if isGenDecl(decl) {
		return getGenDeclName(decl.(*ast.GenDecl)) + "_type"
	}
	panic("unknown decl kind")
}

func stringifyDecl(decl ast.Decl) string {
	var buf bytes.Buffer
	printer.Fprint(&buf, token.NewFileSet(), decl)
	return buf.String()
}

func main() {
	inputDirectoryFlag := *flag.String("i", "./", "input directory")
	outputFileName := *flag.String("o", "stringified_decls.go", "output file")
	packageName := *flag.String("p", "main", "package name")
	outputDeclsPrefix := *flag.String("prefix", "", "prefix of output declaraton names")
	flag.Parse()

	inputFiles := scanFiles(inputDirectoryFlag)
	outputFile := newOutputFile(outputFileName, outputDeclsPrefix, packageName)
	for _, inputFile := range inputFiles {
		for _, decl := range inputFile.decls {
			outputFile.writeDecl(decl, inputFile.name)
		}
	}

	outputFile.formatContent().writeFile()
}

func isImportDecl(decl ast.Decl) bool {
	if genDecl, ok := decl.(*ast.GenDecl); ok {
		if genDecl.Tok == token.IMPORT {
			return true
		}
	}
	return false
}

func isFuncDecl(decl ast.Decl) bool {
	if _, ok := decl.(*ast.FuncDecl); ok {
		return true
	}
	return false
}

func isGenDecl(decl ast.Decl) bool {
	if _, ok := decl.(*ast.GenDecl); ok {
		return true
	}
	return false
}

// on file name "foo.bar.go" the import will be named "foo_bar"
func evalImportName(containingFileName string) string {
	return strings.Replace(containingFileName, ".", "_", -1)
}

func getFuncName(decl *ast.FuncDecl) string {
	if decl.Recv == nil {
		return decl.Name.Name
	}
	// fmt.Println(ast.Print(token.NewFileSet(), decl))
	receiverName := findMethodReceiverIdent(decl.Recv.List[0].Type)
	return decl.Name.Name + "_" + receiverName.Name
}

func findMethodReceiverIdent(expr ast.Expr) *ast.Ident {
	if identType, ok := expr.(*ast.Ident); ok {
		return identType
	}
	if arrayType, ok := expr.(*ast.ArrayType); ok {
		return findMethodReceiverIdent(arrayType.Elt)
	}
	return findMethodReceiverIdent(expr.(*ast.StarExpr).X)
}

func getGenDeclName(decl *ast.GenDecl) string {
	if typeSpec, ok := decl.Specs[0].(*ast.TypeSpec); ok {
		return typeSpec.Name.Name
	}
	return decl.Specs[0].(*ast.ValueSpec).Names[0].Name
}
